# Day 6

- [x]  solve leetcode problem 2 [https://leetcode.com/problems/max-consecutive-ones/description/](https://leetcode.com/problems/max-consecutive-ones/description/)
- [ ]  Solve 1 or more codeforces problem
- [ ]  Complete excercise 5
- [x]  Continue chai or code JavaScript part 2
- [ ]  Start watching hitesh chaudhry css crash course on PW skills channel
- [ ]  [https://drive.google.com/drive/folders/1W2bCjekTJ4wA5eI6aoAQryXBAKBMK-HZ?usp=drive_link](https://drive.google.com/drive/folders/1W2bCjekTJ4wA5eI6aoAQryXBAKBMK-HZ?usp=drive_link) complete this 1st project from 50 projects in 50 days
- Post it on
- [ ]  medium
- [x]  hashnode
- [x]  dev.to
- [x]  twitter

## What I learned?

I learned the following topics:

- call in javascript
- classes in javascript
- Inheritance insights in javascript
- How to use map data structure to solve problem

## What I developed-solved?

- solved 1 leetcode problem 485. **Max Consecutive Ones**
- Solved 1 leetcode problem 136. Single number

## Difficulties I am facing.

- I am facing difficulties in figuring out the time complexity of map based data structure
- I am facing difficulties in understading context(current execting context and global executing context) in javascript

## Code snippet-screenshots-notes

1. Leetcode 485. Max consecutive ones
- problem statement: Given a binary array `nums`, return *the maximum number of consecutive* `1`*'s in the array*.

```css
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int size = nums.size();
        int cnt = 0, maxi = 0;
        for (int i = 0; i < size; i++) {
            /*we maintain a count variable to count the number of consecutive ones
            and when we encountered a 0, the count variable becomes 0 again
            */ 
            if (nums[i] == 1) {
                cnt++;  
                /*maintaining maxi variable to store maximum number of
                consecutive ones
                */ 
                if (cnt > maxi) {
                    maxi = cnt;
                }
            }
            else{
                cnt = 0;
            }
        }
        return maxi;
    }
};

//Time complexity: O(n), n = number of elements in an array
//Space Complexity: O(1), because we are not using any extra space
```

1. Leetcode 136. Single number
- Problem statement: Given a **non-empty** array of integers `nums`, every element appears *twice* except for one. Find that single one.
- example.

```
Input: nums = [2,2,1]
Output: 1
```

```
Input: nums = [4,1,2,1,2]
Output: 4
```

```
Input: nums = [1]
Output: 1
```

- Brute force approach

```css
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int size = nums.size();
        for(int i = 0; i<nums.size(); i++){
            /*1. grab a single element
              2. find that element in the entire array
              3. if that element appears for the second time increase cnt count
              4. if that element doesn't appear more than ones, the
                 cnt remains 0 and that's our final answer         
            */
            int number = nums[i]; 
            int cnt = 0;
            for(int j = 0; j<nums.size(); j++){
                if(nums[j] == number && i != j){
                   cnt++;
                }
            }
            if(cnt==0){
                return number;
            }
        }
        return -1;
    }
};
//Time Complexity: O(n)*O(n)=O(n^2)
//Space Comlexity: O(1), 
```

- better approach using (map data structure)

```css
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        map<long long, int> m;

        for(int i = 0; i<nums.size(); i++){
            m[nums[i]]++;
        }

        /* 1.map all the elements in key-value pairs 
           2.Iterate through the map and search for the value of key to be 1
           3.return value's key which is our final answer
        */
        
        for(auto it: m){
            if(it.second == 1){
                return it.first;
            }
        }
        return -1;
    }
};
/* Time complexity: O(N*logM) + O(M), where M = size of the map(i.e. m = (n/2)+1 )
   N = size of an array
   -> we are inserting N element in map, and insertion takes logM time
   
   Space complexity: O(M) where M = size of the map ( m = (n/2)+1 )
   we are using map data structure to store elements in key-value pairs
*/
```

- Optimal Solution

```css
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for(int i = 0; i<nums.size(); i++){
           ans = (ans ^ nums[i]);  
        }
        return ans;
    }
};
/* Example: nums = [4, 1, 2, 1, 2]
   = 1 ^ 1 ^ 2 ^ 2 ^ 4
   = ( 0 ) ^ ( 0 ) ^ 4
   => 0^0 = 0
   => 0^4 = 4 
   -> because 0 ^ number = (number itself),
   number ^ same number = 0
*/
/* Time complexity: O(n), where n = number of elements in an array
   Space complexity: O(1), because we are not using any extra space
*/
```

---

## JavaScript call

it calls a method of an object, substituing another object for a current object

```css
function SetUsername(username) {
    this.username = username
}

function createuser(username, email, password) {
    SetUsername.call(this, username)

    this.email = email
    this.password = password
}

const user1 = new createuser("user1", "user1@gmail.com", "something")
console.log(user1.username) //output: user1
```

## Classes in javaScript

```jsx
class User {
    constructor(username, email, password) {
        this.username = username
        this.email = email
        this.password = password
    }

    encryptPassword() {
        return `${this.password}ads`
    }

    changeUsername() {
        return `${this.username.toUpperCase()}`
    }
}

const userDetails = new User("user", "user@gmail.com", "12345")

console.log(userDetails.encryptPassword()) //12345ads
console.log(userDetails.changeUsername()) //USER

// Behind the scenes

function User2(username, email, password) {
    this.username = username
    this.email = email
    this.password = password
}

User2.prototype.encryptPassword = function () {
    return `${this.password}ads`
}

User2.prototype.changeUsername = function () {
    return `${this.username.toUpperCase()}`
}

const user2 = new User2("user2", "user2@gmail.com", "userPwd")
console.log(user2.encryptPassword()) //userPwdads
console.log(user2.changeUsername()) //user2 to USER2
```

## Inheritance

```jsx
**class User {
    constructor(username) {
        this.username = username
    }

    login() {
        return `${this.username} logged in successfully!`
    }
}

//'Teacher' inherits (acquires) properties of base class which is 'User')
class Teacher extends User {
    constructor(username, email, password) {
        super(username)
        this.email = email
        this.password = password
    }

    addCourse() {
        console.log(`A new course was added by ${this.username}`)
    }
}

const teacher = new Teacher("teacher1", "teacher1@gmail.com", "teacherPWD")
console.log(teacher.login()) //teacher1 logged in successfully!

const user = new User("user1")
console.log(user.username) //user1

console.log(teacher instanceof Teacher) //true
console.log(user instanceof User) //true
console.log(teacher instanceof User) //true**
```

## Static properties

```jsx
class user {
    constructor(username) {
        this.username = username
    }

    logme() {
        console.log(`Username is: ${this.username}`)
    }
}

const Goblin = new user("something new")
Goblin.logme() //Username is: something new
```